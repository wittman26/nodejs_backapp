package com.acelera.fx.db.infrastructure.adapter.persistence.jpa.model;

import com.acelera.data.jpa.BaseAuditorJpa;
import lombok.*;

import javax.persistence.*;
import javax.validation.constraints.Size;
import java.util.List;

@Entity
@Table(name = "FX_TRADE_SIGNATURE")
@NoArgsConstructor
@AllArgsConstructor
@Builder
@Setter
@Getter
public class TradeSignatureModel extends BaseAuditorJpa {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "TRADE_SIGNATURE_ID")
    private Long tradeSignatureId;

    @Size(max = 4)
    @Column(name = "ENTITY", nullable = false, length = 4)
    private String entity;

    @Column(name = "ORIGIN_ID", nullable = false)
    private Long originId;

    @Size(max = 20)
    @Column(name = "ORIGIN", nullable = false, length = 20)
    private String origin;

    @Size(max = 2)
    @Column(name = "PRODUCT_ID", nullable = false, length = 2)
    private String productId;

    @Size(max = 10)
    @Column(name = "SIGNATURE_TYPE", nullable = false, length = 10)
    private String signatureType;

    @Size(max = 1)
    @Column(name = "INDICATOR_SSCC", length = 1)
    private String indicatorSSCC;

    @Size(max = 10)
    @Column(name = "VALIDATED_BO", length = 10)
    private String validatedBo;

    @Column(name = "EXPEDIENT_ID")
    private Long expedientId;

    @OneToMany(mappedBy = "tradeSignatureModel", fetch = FetchType.LAZY, cascade = CascadeType.ALL, orphanRemoval = true)
    private List<TradeSignerModel> tradeSignerList;
}

package com.acelera.fx.db.infrastructure.adapter.persistence.jpa.model;

import com.acelera.data.jpa.BaseAuditorJpa;
import lombok.*;

import javax.persistence.*;
import javax.validation.constraints.Size;

@Entity
@Table(name = "FX_TRADE_SIGNER")
@NoArgsConstructor
@AllArgsConstructor
@Builder
@Setter
@Getter
public class TradeSignerModel extends BaseAuditorJpa {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "TRADE_SIGNER_ID")
    private Long tradeSignerId;

    @Size(max = 1)
    @Column(name = "DOCUMENT_TYPE", nullable = false, length = 1)
    private String documentType;

    @Size(max = 20)
    @Column(name = "DOCUMENT_NUMBER", nullable = false, length = 20)
    private String documentNumber;

    @Size(max = 10)
    @Column(name = "SIGNER_ID", nullable = false, length = 10)
    private String signerId;

    @Size(max = 200)
    @Column(name = "NAME", nullable = false, length = 200)
    private String name;

    @Size(max = 1)
    @Column(name = "IS_CLIENT", nullable = false, length = 1)
    private String isClient;

    @Size(max = 2)
    @Column(name = "INTERVENTION_TYPE", nullable = false, length = 2)
    private String interventionType;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "TRADE_SIGNATURE_ID", referencedColumnName = "TRADE_SIGNATURE_ID")
    private TradeSignatureModel tradeSignatureModel;
}

@Repository
@RequiredArgsConstructor
public class JpaTradeSignatureRepositoryImpl implements TradeSignatureRepository {

    private final SpringJpaTradeSignatureRepository repository;

    @Override
    public TradeSignature save(TradeSignature tradeSignature) {
        TradeSignatureModel tradeSignatureModel = TradeSignatureMapper.INSTANCE.fromDomain(tradeSignature);

        if(tradeSignatureModel.getTradeSignerList()!= null) {
            tradeSignatureModel.getTradeSignerList()
                    .forEach(signer -> signer.setTradeSignatureModel(tradeSignatureModel));
        }

        var model = repository.save(tradeSignatureModel);
        return TradeSignatureMapper.INSTANCE.toDomain(model);
    }

    @Override
    public Optional<TradeSignature> find(TradeSignatureFindRequest request) {
        Optional<TradeSignatureModel> model;
        if(request.getTradeSignatureId() != null) {
             model = repository.findById(request.getTradeSignatureId());
        } else {
            model = repository.find(request);
        }
        return model.map(TradeSignatureMapper.INSTANCE::toDomain);
    }
}

public interface SpringJpaTradeSignatureRepository extends CrudRepository<TradeSignatureModel, Long> {
    // @formatter:off
    @Query(nativeQuery = true, value = "SELECT * "
            + "FROM ACELER_FX.FX_TRADE_SIGNATURE "
            + "WHERE "
            + "(:#{#filter.entity} IS NULL OR ENTITY = :#{#filter.entity}) AND "
            + "(:#{#filter.originId} IS NULL OR ORIGIN_ID = :#{#filter.originId}) AND "
            + "(:#{#filter.productId} IS NULL OR PRODUCT_ID = :#{#filter.productId})"
    )
    // @formatter:on
            Optional<TradeSignatureModel> find(TradeSignatureFindRequest filter);

    @EntityGraph(attributePaths = "tradeSignerList")
    @NotNull Optional<TradeSignatureModel> findById(@NotNull Long id);
}

2025-05-30 14:48:35.445  INFO [conac-springboot-fx-db,6eaa583053f15f8a,78e3d36a61342d68] 16248 --- [ctor-http-nio-4] c.a.b.shared.domain.RSocketProxyLogs     : server: {"correlationId":1748609315443967459,"route":"trade-signature.find","messageType":"request","rsocketType":"requestResponse","payload":{"tradeSignatureId":null,"entity":"0049","originId":123450,"productId":"FW"},"metadata":{"acelera.ctx":{"entity":"0049","locale":"es_ES"}}}
2025-05-30 14:48:51.099 DEBUG [conac-springboot-fx-db,6eaa583053f15f8a,78e3d36a61342d68] 16248 --- [oundedElastic-5] org.hibernate.SQL                        : 
    SELECT
        *    
    FROM
        ACELER_FX.FX_TRADE_SIGNATURE    
    WHERE
        ? IS NULL 
        OR ENTITY = ? 
        AND          ? IS NULL 
        OR ORIGIN_ID = ? 
        AND          ? IS NULL 
        OR PRODUCT_ID = ?
)
2025-05-30 14:48:51.559 TRACE [conac-springboot-fx-db,6eaa583053f15f8a,78e3d36a61342d68] 16248 --- [oundedElastic-5] o.h.type.descriptor.sql.BasicBinder      : binding parameter [1] as [VARCHAR] - [0049]
2025-05-30 14:48:51.561 TRACE [conac-springboot-fx-db,6eaa583053f15f8a,78e3d36a61342d68] 16248 --- [oundedElastic-5] o.h.type.descriptor.sql.BasicBinder      : binding parameter [2] as [VARCHAR] - [0049]
2025-05-30 14:48:51.563 TRACE [conac-springboot-fx-db,6eaa583053f15f8a,78e3d36a61342d68] 16248 --- [oundedElastic-5] o.h.type.descriptor.sql.BasicBinder      : binding parameter [3] as [INTEGER] - [123450]
2025-05-30 14:48:51.565 TRACE [conac-springboot-fx-db,6eaa583053f15f8a,78e3d36a61342d68] 16248 --- [oundedElastic-5] o.h.type.descriptor.sql.BasicBinder      : binding parameter [4] as [INTEGER] - [123450]
2025-05-30 14:48:51.565 TRACE [conac-springboot-fx-db,6eaa583053f15f8a,78e3d36a61342d68] 16248 --- [oundedElastic-5] o.h.type.descriptor.sql.BasicBinder      : binding parameter [5] as [VARCHAR] - [FW]
2025-05-30 14:48:51.565 TRACE [conac-springboot-fx-db,6eaa583053f15f8a,78e3d36a61342d68] 16248 --- [oundedElastic-5] o.h.type.descriptor.sql.BasicBinder      : binding parameter [6] as [VARCHAR] - [FW]
2025-05-30 14:48:51.648  WARN [conac-springboot-fx-db,6eaa583053f15f8a,78e3d36a61342d68] 16248 --- [oundedElastic-5] o.h.engine.jdbc.spi.SqlExceptionHelper   : SQL Error: 933, SQLState: 42000
2025-05-30 14:48:51.648 ERROR [conac-springboot-fx-db,6eaa583053f15f8a,78e3d36a61342d68] 16248 --- [oundedElastic-5] o.h.engine.jdbc.spi.SqlExceptionHelper   : ORA-00933: comando SQL no terminado correctamente

2025-05-30 14:48:51.649 ERROR [conac-springboot-fx-db,6eaa583053f15f8a,78e3d36a61342d68] 16248 --- [oundedElastic-5] o.s.m.h.i.reactive.InvocableHelper       : No exception handling method

org.springframework.dao.InvalidDataAccessResourceUsageException: could not extract ResultSet; SQL [n/a]; nested exception is org.hibernate.exception.SQLGrammarException: could not extract ResultSet
