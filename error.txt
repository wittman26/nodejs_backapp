@Entity
@Table(name = "FX_TRADE_SIGNATURE")
@NoArgsConstructor
@AllArgsConstructor
@Builder
@Setter
@Getter
public class TradeSignatureModel extends BaseAuditorJpa {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "TRADE_SIGNATURE_ID")
    private Long tradeSignatureId;

    @Size(max = 4)
    @Column(name = "ENTITY", nullable = false, length = 4)
    private String entity;

    @Column(name = "ORIGIN_ID", nullable = false)
    private Long originId;

    @Size(max = 20)
    @Column(name = "ORIGIN", nullable = false, length = 20)
    private String origin;

    @Size(max = 2)
    @Column(name = "PRODUCT_ID", nullable = false, length = 2)
    private String productId;

    @Size(max = 10)
    @Column(name = "SIGNATURE_TYPE", nullable = false, length = 10)
    private String signatureType;

    @Size(max = 1)
    @Column(name = "INDICATOR_SSCC", length = 1)
    private String indicatorSSCC;

    @Size(max = 10)
    @Column(name = "VALIDATED_BO", length = 10)
    private String validatedBo;

    @Column(name = "EXPEDIENT_ID")
    private Long expedientId;

    @OneToMany(mappedBy = "tradeSignatureModel", fetch = FetchType.LAZY, cascade = CascadeType.ALL)
    private List<TradeSignerModel> tradeSignerList;
}

@Entity
@Table(name = "FX_TRADE_SIGNER")
@NoArgsConstructor
@AllArgsConstructor
@Builder
@Setter
@Getter
public class TradeSignerModel extends BaseAuditorJpa {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "TRADE_SIGNER_ID")
    private Long tradeSignerId;

    @Column(name = "TRADE_SIGNATURE_ID", nullable = false)
    private Long tradeSignatureId;

    @Size(max = 1)
    @Column(name = "DOCUMENT_TYPE", nullable = false, length = 1)
    private String documentType;

    @Size(max = 20)
    @Column(name = "DOCUMENT_NUMBER", nullable = false, length = 20)
    private String documentNumber;

    @Size(max = 10)
    @Column(name = "SIGNER_ID", nullable = false, length = 10)
    private String signerId;

    @Size(max = 200)
    @Column(name = "NAME", nullable = false, length = 200)
    private String name;

    @Size(max = 1)
    @Column(name = "IS_CLIENT", nullable = false, length = 1)
    private String isClient;

    @Size(max = 2)
    @Column(name = "INTERVENTION_TYPE", nullable = false, length = 2)
    private String interventionType;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "TRADE_SIGNATURE_ID", referencedColumnName = "TRADE_SIGNATURE_ID", insertable = false, updatable = false)
    private TradeSignatureModel tradeSignatureModel;
}

@DataJpaTest
@Import({ PersistenceAutoConfig.class, JpaTradeSignatureRepositoryImpl.class})
public class JpaTradeSignatureRepositoryImplTest {

    private static final PodamFactory PODAM_FACTORY = new PodamFactoryImpl();
    private static final TradeSignatureMapper MAPPER = TradeSignatureMapper.INSTANCE;

    private @Autowired JpaTradeSignatureRepositoryImpl impl;
    private @Autowired EntityManager em;

    @BeforeEach
    void setUp() {
        AttributeStrategy<Long> idStrategy = (attrType, attrAnnotations) -> null;
        var strategy =
                PODAM_FACTORY.getStrategy().addOrReplaceAttributeStrategy(TradeSignatureModel.class, "id", idStrategy)
                        .addOrReplaceAttributeStrategy(TradeSignerModel.class, "id", idStrategy);
        PODAM_FACTORY.setStrategy(strategy);
    }

    @Test
    void testSave() {
        TradeSignatureModel model = PODAM_FACTORY.manufacturePojo(TradeSignatureModel.class);

        model.setTradeSignatureId(null);

        if(model.getTradeSignerList() != null) {
            for(TradeSignerModel signer: model.getTradeSignerList()) {
                signer.setTradeSignerId(null);
                signer.setTradeSignatureModel(model);
                signer.setTradeSignatureId(null);
            }
        }

        TradeSignature tradeSignature = MAPPER.toDomain(model);
        var response = impl.save(tradeSignature);
        assertThat(response).as("save trade signature").usingRecursiveComparison()
                .ignoringFieldsMatchingRegexes(".*tradeSignatureId", ".*usumodi", ".*fecmodi", ".*usualta", ".*fecalta")
                .isEqualTo(tradeSignature);
    }
}


Hibernate: insert into fx_trade_signature (trade_signature_id, fecalta, fecmodi, usualta, usumodi, entity, expedient_id, indicator_sscc, origin, origin_id, product_id, signature_type, validated_bo) values (default, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
Hibernate: insert into fx_trade_signer (trade_signer_id, fecalta, fecmodi, usualta, usumodi, document_number, document_type, intervention_type, is_client, name, signer_id, trade_signature_id) values (default, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
2025-05-30 08:45:39.071  WARN [conac-springboot-test-db,,] 6928 --- [           main] o.h.engine.jdbc.spi.SqlExceptionHelper   : SQL Error: 23502, SQLState: 23502
2025-05-30 08:45:39.071 ERROR [conac-springboot-test-db,,] 6928 --- [           main] o.h.engine.jdbc.spi.SqlExceptionHelper   : La columna "TRADE_SIGNATURE_ID" no permite valores nulos (NULL)
NULL not allowed for column "TRADE_SIGNATURE_ID"; SQL statement:
insert into fx_trade_signer (trade_signer_id, fecalta, fecmodi, usualta, usumodi, document_number, document_type, intervention_type, is_client, name, signer_id, trade_signature_id) values (default, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?) [23502-214]
2025-05-30 08:45:39.098  INFO [conac-springboot-test-db,,] 6928 --- [           main] o.s.t.c.transaction.TransactionContext   : Rolled back transaction for test: [DefaultTestContext@7331196b testClass = JpaTradeSignatureRepositoryImplTest, testInstance = com.acelera.fx.db.infrastructure.adapter.persistence.jpa.repository.JpaTradeSignatureRepositoryImplTest@32a68f4f, testMethod = testSave@JpaTradeSignatureRepositoryImplTest, testException = org.springframework.dao.DataIntegrityViolationException: could not execute statement; SQL [n/a]; constraint [null]; nested exception is org.hibernate.exception.ConstraintViolationException: could not execute statement, mergedContextConfiguration = [MergedContextConfiguration@3f9342d4 testClass = JpaTradeSignatureRepositoryImplTest, locations = '{}', classes = '{class com.acelera.fx.db.FxDbApplication}', contextInitializerClasses = '[]', activeProfiles = '{}', propertySourceLocations = '{}', propertySourceProperties = '{org.springframework.boot.test.autoconfigure.orm.jpa.DataJpaTestContextBootstrapper=true}', contextCustomizers = set[[ImportsContextCustomizer@ab7395e key = [org.springframework.boot.autoconfigure.transaction.TransactionAutoConfiguration, org.springframework.boot.autoconfigure.data.jpa.JpaRepositoriesAutoConfiguration, org.springframework.boot.test.autoconfigure.orm.jpa.TestEntityManagerAutoConfiguration, org.springframework.boot.autoconfigure.cache.CacheAutoConfiguration, org.springframework.boot.autoconfigure.orm.jpa.HibernateJpaAutoConfiguration, org.springframework.boot.autoconfigure.sql.init.SqlInitializationAutoConfiguration, org.springframework.boot.test.autoconfigure.jdbc.TestDatabaseAutoConfiguration, org.springframework.boot.autoconfigure.flyway.FlywayAutoConfiguration, org.springframework.boot.autoconfigure.jdbc.DataSourceTransactionManagerAutoConfiguration, org.springframework.boot.autoconfigure.liquibase.LiquibaseAutoConfiguration, com.acelera.data.jpa.PersistenceAutoConfig, org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration, org.springframework.boot.autoconfigure.jdbc.JdbcTemplateAutoConfiguration, com.acelera.fx.db.infrastructure.adapter.persistence.jpa.repository.JpaTradeSignatureRepositoryImpl]], org.springframework.boot.test.context.filter.ExcludeFilterContextCustomizer@76b07f29, org.springframework.boot.test.json.DuplicateJsonObjectContextCustomizerFactory$DuplicateJsonObjectContextCustomizer@62656be4, org.springframework.boot.test.mock.mockito.MockitoContextCustomizer@0, org.springframework.boot.test.autoconfigure.OverrideAutoConfigurationContextCustomizerFactory$DisableAutoConfigurationContextCustomizer@81d9a72, org.springframework.boot.test.autoconfigure.actuate.metrics.MetricsExportContextCustomizerFactory$DisableMetricExportContextCustomizer@70e38ce1, org.springframework.boot.test.autoconfigure.filter.TypeExcludeFiltersContextCustomizer@351584c0, org.springframework.boot.test.autoconfigure.properties.PropertyMappingContextCustomizer@1a8b1d7a, org.springframework.boot.test.autoconfigure.web.servlet.WebDriverContextCustomizerFactory$Customizer@16c069df, org.springframework.boot.test.context.SpringBootTestArgs@1, org.springframework.boot.test.context.SpringBootTestWebEnvironment@0], contextLoader = 'org.springframework.boot.test.context.SpringBootContextLoader', parent = [null]], attributes = map['org.springframework.test.context.event.ApplicationEventsTestExecutionListener.recordApplicationEvents' -> false]]

org.springframework.dao.DataIntegrityViolationException: could not execute statement; SQL [n/a]; constraint [null]; nested exception is org.hibernate.exception.ConstraintViolationException: could not execute statement
